/*
윤호와 동혁이는 BOJ 알고리즘 캠프에 참가중이다. 
두 사람은 문제가 너무 안 풀릴 때는 게임을 하고 문제를 풀기도 한다.

게임은 턴으로 이루어져 있으며, 각 턴의 승자는 두 사람 중에 한 사람이다. 
i번째 턴을 승리한 사람은 점수 i점을 갖게 되고, 턴은 1부터 시작한다.

두 정수 x와 y가 주어졌을 때, 윤호의 점수가 x, 
동혁이의 점수가 y가 되는 것이 가능한지 불가능한지 구하는 프로그램을 작성하시오. 
만약, 가능하다면 윤호가 최소 몇 번 이겨야 하는지도 구하시오.

풀이 :

- x점과 y점이 존재할 수 있는지는 어떻게 알 수 있을까?

    - 게임을 1 턴 부터 r 턴 까지 진행했다고 가정하자. 각 턴마다 이긴 사람은 자신의 점수에 현재 턴 (i) 만큼 점수가 추가 됨. 
        == 얻을 수 있는 점수들은 음의 값이 될 수 없고 1씩 증가하는 등차수열
    - 두 사람이서 게임을 진행하고, 무승부는 없다고 했으므로 윤호의 점수 x 와 동혁이의 점수 y를 더하면 1부터 r 까지의 등차 수열의 합이 될 것이다.
    - x + y = 1 + 2 + ... + r 을 성립 시키는 r 이 존재하는지 확인해야 할 것.
    - r의 존재는 ? x + y = ( 1 + r ) r / 2  로 둘 수 있으므로 이차방정식 풀면 될 것 같음.
        2 ( x + y ) = r ^ 2 + r
        이차방정식은 어떻게 값을 구하지?? 근의 공식 쓰나? r은 일단 양수고, 중근이어야 할테니까... 판별식이 0 나와야할 듯?
        a == 1/2, b == 1/2, c == - ( x + y )
        -> a == 1, b == 1, c = - 2 ( x + y )

        // 근데 이거 잘 모르겠어 ㅠㅠ 그냥 브루트 포스 돌려볼까... 역시나 시간 초과되네

- 윤호는 최소 몇번 이겨야 할까?

    - 맨 뒤의 r 부터 시작해서 합이 x를 만드는 조합을 찾으면 된다.
    - 이게 어렵네. 이거 생각 좀 다시 해봐야할 듯. 그냥 나이브하게 하면 r! 검사해야 함 ㅠㅠ
        - r 부터 내려가면서 r이 x 보다 작거나 같다면, x - r 하며 x 을 업데이트 + 카운터 증가 시키기 해볼까? 이러면 O(r) 걸리겠다.
        - 최소 횟수로 이기려면 무엇보다 가능한 한 큰 수가 x에서 빠질 수록 횟수가 적어질 테니까

알고리즘 :
    1. 1부터 r 까지 더해서 x + y 가 되는 r 이 있는지 검사. (등차 수열의 합 공식, 근의 공식 사용.) 
    2. r + ( r - 1 ) + ( r - 2 ) + .... 해서 x 를 만들기 까지 몇 번이 걸렸는지 확인. 

*/

#include <iostream>
#include <math.h>
using namespace std;

int main() {
    
    // x와 y 초기화
    long long x = 0, y = 0;

    cin >> x >> y ;

    long long r = 0;
    long long r2 = 0;
    // r 찾기. 브루트포스... 시간초과
    // for (long long i = 1; i <= x + y; i++ ){
        
    //     if (i*i + i == 2 * (x + y)){
    //         r = i;
    //         break;
    //     }
    // }

    long long a = 1, b = 1;

    long long c = -2.0 * (x + y);
    double D = (double)b*b - 4.0 * ( ( (double) a * c ));
    // cout << "D : " << D << "\n";

    if ( D < 0 ){
        // 실근 자체가 없는 경우에는 어차피 나가리.;
        cout << -1 << "\n";
        exit;
    }
    else {

        // 우리가 필요한 r은 양의 정수일텐데, 판별식 만으로는 그걸 알 수 없으니 
        // r 또는 r2가 제대로 된 양의 정수인지 체크해야 함.
        r = ( -1 + sqrt(D) ) / 2.0;
        r2 = ( -1 - sqrt(D) ) / 2.0;

        // r^2 + r - 2(x+y) 랑 값 비교해보고 맞으면 해가 맞겠지... 다른 방법이 있나?
        bool rValid = true;
        bool r2Valid = true;

        long long resR = r*r + r + c;
        long long resR2 = r2*r2 + r2 + c;

        // cout << " resR : " << resR <<  "\t resR2 : " << resR2 << "\n";


        if ( resR != 0 ) {
            rValid = false;
        }
        if ( resR2 != 0 ) {
            r2Valid = false;
        }

        if ( ! ( rValid || r2Valid )){
            cout << -1;
            return 0;
        }


        // cout << " r : " << r <<  "\t r2 : " << r2 << "\n";

        // 횟수 구하기
        long long cnt = -1;
        if ( r ) {
            cnt = 0;
            for (long long i = r; i > 0; i--){
                if ( i <= x ){
                    x -= i;
                    cnt++;
                }
            }
        }
    
        cout << cnt;
    }

}